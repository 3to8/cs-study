<details>
<summary>
배열과 링크드 리스트 차이</summary>
<div>

### 배열

- 크기가 정해져 있다.
- 연속된 메모리 공간에 저장된다.

#### 문제점

- 더 많은 데이터를 저장하고싶다면?
    - 새로운 공간을 만들어서 옮겨야 한다.
- 중간에 데이터를 저장하거나 삭제하는 경우
    - 여러개의 데이터를 옮겨야한다.

### Linked List

- 연속된 공간에 데이터를 저장하지 않는다.
- 노드들로 구성되어있다.
- 첫번째 노드는 헤드라고 불리며 next로 연결되어있음

### 실제로는 동적 배열을 더욱 많이 사용

- 연결 리스트는 조회가 느리기 때문
- 중간 추가, 삭제 또한 비용이 든다.
- 다음 노드를 기억하는데 추가 메모리 사용
- 메모리가 퍼져있으므로 캐시의 효과를 누리지 못한다.(데이터가 메모리에 순서대로 저장되어 있기 때문)

### 그럼 언제 연결 리스트를 사용하나?

- 잦은 추가와 삭제가 이뤄질때

</div>
</details>

<br>

<details>
<summary>컬렉션 프레임워크</summary>
<div>

## 컬렉션 프레임워크에 대한 설명
- 다수의 데이터를 쉽고 효과적으로 관리할 수 있는 표준화된 방법을 제공하는 클래스의 집합
- 자바 컬렉션에는 List,Set,Map 인터페이스를 기준으로 여러 구현체가 존재하며, 더 나아가 Stack, Queue 인터페이스도 존재

### List,Set,Map의 특징에 대해 설명
- List는 순서가 있는 데이터의 집합이며 데이터 중복을 허용(ArrayList, LinkedList)
- Set은 순서가 없는 데이터 집합이며, 데이터의 중복을 허용하지 않는다(HashSet,LinkedHashSet,TreeSet)
- Map은 key value가 쌍으로 이루고있으며, 키를 기준으로 중복을 허용하지 않고, 순서가 없습니다. Key의 순서를 보장하기 위해서는 LinkedHashMap 사용 (HashMap, TreeMap, HashTable)

### Set과 Map의 타입이 Wrapper Class가 아닌 Object를 받을때 중복은 어떻게 하는지 설명
- hashCode() 메서드를 오버라이딩해 리턴된 해시코드 값이 같은지 보고 다르다면 다른 객체로 판단, 같으면 equals()메서드로 오버라이딩해 다시 비교 두개가 모두 맞다면 중복 객체

### 컬렉션 프레임워크를 쓰는 이유 설명
- 배열을 사용하다 보면 여러 비효율적인 문제가 생기는데 그중 크기가 고정적이라는 문제가 있다. 배열의 크기는 생성될때 결정되며, 그 이상 넘어가면 데이터 저장 불가능하다. 또한 데이터를 삭제하면 해당 인덱스는 비어있어 메모리 낭비가된다.
- 이러한 문제점을 해결하기 위해 추가, 삭제, 검색 ,저장이 가능한 자료구조를 만들어 놓았다.

### ArrayList에 대해 설명
- 크기가 가변적으로 변하는 선형 리스트
- 객체들이 추가되어 용량 초과시 자동으로 용량이 늘어난다.

### LinkedList에 대해 설명
- 각 노드가 데이터와 포인터를 가지며, 한 줄로 연결된 자료구조
- 특정 요소 접근하기 위해서는 순차 탐색이 필요함으로 탐색속도가 떨어진다

### ArrayList vs LinkedList
- 검색 또는 정렬을 자주하는 경우 배열
- 데이터의 추가,삭제가 많은 경우 linkedlist

### HashSet에 대해 설명
- 객체를 중복해서 저장할 수 없고 하나의 null 값만 저장가능
- 저장 순서가 유지되지 않는다

#### 저장 순서를 유지해야한다면?
- LinkedHashSet 클래스 사용

#### HashSet vs TreeSet
- 자동 정렬을 해주고 안해주고의 차이점이 존재

#### Set 장점 단점
- 장점
  - 중복을 자동으로 제거, 비선형 구조이기에 순서가 없으며, 그렇기에 인덱스도 존재하지 않음
- 단점
  - 값을 추가하거나 삭제할 때 값이 내부에 있는지 검색한 뒤 추가나 삭제를 함으로 list구조에 비해 속도가 느리다

#### HashSet에서 중복을 걸러내는 과정?
- 객체를 저장하기 전 객체의 hashCode()메서드 호출후 해시코드를 얻어내 저장된 객체들의 해시코드와 비교한 뒤 같은 해시코드가 있으면 equals()메서드로 다시 비교해 true가 나오면 같은 객체로 판단후 중복 저장하지 않는다.

### TreeSet에 대해 설명
- 마찬가지로 중복해 저장할 수 없으며, 저장 순서가 유지되지 않는다.
- 이진 탐색 트리 구조로 이루어져 추가 삭제에 시간은 더 걸리지만 정렬, 검색에 높은 성능이 있다.

### TreeSet의 구조?
- 이진탐색트리 중 성능이 향상된 레드-블랙-트리로 구현
- 일반적인 이진 탐색 트리는 트리 높이만큼 시간이 걸린다.
- 한쪽으로 치우칠 경우 비효율적

### 레드 블랙 트리?
- 부모 노드보다 작은 값을 가지는 노드는 왼쪽 큰 값은 오른쪽으로 배치한다
- 루트노드와 모든 리프 노드는 검정색이며, 빨간 노드의 자식은 항상 검정색

### HashMap에 대해 설명
- key value 쌍으로 구성된 자료구조이며 키 값 모두 객체이다.
- 값은 중복되지만 키는 중복 불가능
- 만약 중복해서 저장시 새로운 값으로 대치

### HashTable과 HashMap의 차이점
- HashMap은 보조 해시 함수를 사용하기에 사용하지 않는 HashTable에 비해 해시 충돌이 덜 일어나 성능상 이점
- HashTable은 동기화 지원 HashMap은 동기화 지원 안함

### TreeMap에 대해 설명
- 객체를 저장시 자동 정렬(오름차순)
- HashMap에 비해 추가,삭제 성능이 떨어짐 
- 정렬된 데이터에서 조회할경우 성능이 더 좋다

### TreeMap과 TreeSet의 차이점?
- set은 값만 저장 map은 키와 값으로 구성된 entry 객체 저장

### Tree란 무엇일까?
- Tree는 비선형 자료구조 중 하나입니다.
- 비선형이란 말 그대로 일직선으로 나타내지 못하는 방식이며, 그중 트리는 계층적 구조를 띄고 있습니다.

#### 그럼 계층적 구조에 어떻게 자료를 저장하나?
1. 데이터와 연결 상태를 저장할 클래스 공간(노드) 생성
2. 각각의 노드들에 값 저장
3. 노드 간 연결 상태 정의

</div>
</details>

<br>

<details>
<summary>Graph</summary>
<div>

### Graph?
- 정점(Node)과 객체를 연결하는 간선(Edge)으로 이루어진 비선형 자료구조

### 무방향, 방향 그래프
- 정점과 간선의 연결관계에 있어 방향성이 없는 그래프를 Undirected Graph 방향성이 있는걸 Directed Graph라고 한다
- Degree(차수)
  - 각 정점에 연결된 edge 개수
  - 방향 그래프는 각 정점으로 나가고 들어오는 outdgree,indegree 존재

### Tree와 다른점은?
- 그래프는 트리와 다르게 정점 마다 간선이 존재하지 않을 수 있으며, 루트 노드와 부모, 자식 노드 개념이 존재하지 않는다.

### 구현 방법?
- 인접 행렬
  - 그래프 정점을 2차원 배열로 만든것
  - 정점간 연결되어 있으면 1 아니면 0
    - 장점
      - 인접 리스트에 비해 구현이 쉽다
    - 단점
      - 필요 이상의 공간 낭비
- 인접 리스트
  - 노드를 리스트로 표현한 것
    - 장점
      - 공간 낭비가 적다
    - 단점
      - 두 정점이 연결되어 있는지 확인이 인접 행렬에 비해 오래 걸린다
      - 구현이 어렵다 인접에 비해

### 그래프 탐색
- 깊이 우선 탐색 (DFS)
  - 갈 수 있는 만큼 최대한 깊이 가고 더이상 없으면 이전 정점으로 돌아가는 방식으로 순회
  - 주로 재귀, 스택 으로 구현
- 너비 우선 탐색 (BFS)
  - 시작 정점을 방문후 인접한 모든 정점을 방문
  - 인접한 정점 방문 뒤, 다시 해당 정점의 인접한 정점을 방문해 순회
  - 주로 큐, 반복문 으로 구현
</div></details>