<details>
<summary>index란?</summary>
<div>

### Index란?
- 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상 시키기 위한 자료구조

#### 쓰는 이유?
- 특정 조건을 만족하는 튜플을 빠르게 조회하기 위해
- 만약 index를 사용하지 않는 컬럼을 조회해야 하는 상황에서는 전체를 탐색하는 Full Scan을 수행해야 한다.(전체를 비교해 탐색하기 때문에 처리 속도가 떨어진다.)

### 단점
- 인덱스를 관리하기 위해 DB의 약 10% 저장공간이 더 필요하다
- 인덱스 된 Field에서 Data를 업데이트 또는 Record를 추가 또는 삭제시 성능이 떨어짐

### 인덱스를 구현하는 자료구조?
- B+ Tree 인덱스 자료구조
  - 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조
  - B-Tree 리프 노드들을 링크드 리스트로 연결해 순차 검색이 가능
</div>
</details>

<br>

<details>
<summary>Redis</summary>
<div>

### Redis란?
- 메모리에 저장해 디스크 스캐닝이 필요없이 매우 빠른 DB
- 캐싱또한 가능해 세션 클러스터링에도 활용된다.
- NoSql로 분류된다.
- key/value 쌍의 해시 맵 형태로 이루어짐
- String, list, hash, set 등의 자료 구조 지원
- 영속성 지원하는 인메모리 데이터 저장소

### cashe??
- 요청할 결과를 미리 저장해 빠르게 서비스해 주는것

### 메모리 저장이면 휘발성인데 어떻게 영속성이냐?
- 영속성 보장을 위해 데이터를 디스크에 저장 하도록 하는 방식이 크게 두가지가 존재
- RDB(Snapshotting)방식
  - 특정 간격마다 메모리에 있는 데이터 전체를 디스크에 쓰는 것
    - AOF 파일보다 사이즈 작고 로딩속도 빠름
- AOF(Append On File)방식
  - 명령이 실행될때 마다 데이터를 파일에 기록해 데이터의 손실이 거의 없다
  - write/update 연산 자체를 모두 log 파일에 기록
  - 서버 재시작시 log 기록을 재 실행

### 장점?
- 싱글 스레드를 사용해 연산이 원자적으로 처리되서 Race Condition 발생이 없다.
  - Race Condition -> 둘 이상의 입력 또는 조작의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태
</div>
</details>

<br>

<details>
<summary>정규화</summary>
<div>

## 정규화 하는 이유?
- 한 릴레이션에 여러 엔티티의 애트리뷰트들이 존재하면 정보가 중복 저장된다.
  - 저장 공간 낭비
  - 갱신 이상 발생

#### 릴레이션?
- RDBMS에서 정보를 구분하여 저장하는 기본 단위
#### 엔티티?
- ERD를 설계하며 도출되는 개체들

#### 애트리뷰트?
- 데이터 베이스를 구성하는 가장 작은 논리적 단위, 흔히 컬럼으로 알고있다.

#### 갱신 이상이 뭐에요?
- 3가지로 나뉨
- 삽입 이상
  - 불필요한 정보를 함께 저장하지 않고는 어떤 정보를 저장하는 것이 불가능
- 삭제 이상
  - 유용한 정보를 함께 삭제하지 않고는 어떤 정보를 삭제하는 것이 불가능
- 수정 이상
  - 반복된 데이터 중 일부만 수정하면 데이터의 불일치가 발생

### 이러한 문제를 해결하기 위해 진행하는 것이 정규화
- 그렇습니다. 위 3가지 갱신 이상이 있는 릴레이션을 분해하여 없애는 과정입니다.
- 단점으로는 JOIN 연산이 많아집니다.

## 제 1 정규화
- 테이블의 컬럼이 원자값(하나의 값)을 갖도록 분해하는 것 입니다.
  - 조건
    - 각 컬럼이 하나의 속성만 가짐
    - 하나의 컬럼은 같은 종류나 타입이 값을 가져야 한다
    - 각 컬럼이 유니크한 이름을 가져야함
    - 컬럼의 순서는 상관 없어야한다.

## 제 2 정규화
- 제 1 정규화가 진행된 테이블에 대해 완전 함수 종속을 만족하도록 테이블 분해
  - 완전 함수 종속이란?
    - 모든 속성이 포함된 기본키의 부분집합에 종속된 경우를 완전함수 종속이라한다.
    - 예) 주민번호 테이블이 있다하면, 이름, 성별, 주소 모두 식별이 가능하지만, 이름은 성별, 주소, 주민번호 어떤것도 식별 불가

## 제 3 정규화
- 제 2 정규화를 진행한 테이블에 대해 이행적 종속이 없도록 테이블을 분해
  - 이행적 종속이란?
    - A -> B , B -> C 가 성립할때 A -> C가 성립하는 것
  - 왜 이행적 종속을 제거 해야하나요?
    - 만약에 학생번호 - 강좌이름 - 수강료 라는 테이블이 있다면
    - A번호 학생이 DB강좌를 수강하고 수강료가 2만원일때 학생이 강좌를 네트워크로 바꾼다면, 수강료가 1만원인데 기존 2만원으로 수강하게되는 오류 존재. 
    - 둘다 바꿀 수 있지만 번거롭다

## BCNF 정규화(Boyce-Codd Normal Form)
- 모든 결정자가 후보키(유일,최소)여야 한다
  - 결정자란?
    - 주민등록번호 릴레이션이 있다 했을때 이름은 동명이인이 있을 수 있어 주민등록번호 속성을 결정하지 못함
    - 주민등록번호(결정자) -> 이름(종속자)
    - 이러한 결정자는 보통 기본키라고 한다
  - 후보키란?
    - 유일성과 최소성을 가지며 유일성은 릴레이션에서 유일하다는 것, 최소성은 최소 집합 관계로 키를 구성하는 것
### 그래서 결정자인데 후보키를 만족한다는 말은?
- 결정자 속성이 다른 속성을 결정할 수있음에도 튜플로 여러번 등장 하지 않아야 한다
- 결정자가 결정하는 속성인 종속자가 기본키의 부분 집합인 경우 제거해야 한다
</div>
</details>