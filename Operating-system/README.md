# Operating System

### Interrupt

<details>
<summary>Interrupt란?</summary>
<br>
<div>
CPU가 프로그램을 실행중일 때 여러 하드웨어 장치에서 예외상황이 발생해 처리가 필요한 경우
CPU에게 알려 처리할 수 있도록 하는 것입니다.

인터럽트가 발생한 시점의 레지스터와 Program Counter를 저장한 후 CPU의 제어를 인터럽트 처리 루틴으로 전달합니다.
</div>

</details>

<br>

<details>
<summary>Interrupt 종류</summary>

<br>

<div>
하드웨어 인터럽트와 소프트웨어 인터럽트가 있습니다.

하드웨어 인터럽트는 입출력 장치나 CPU에 연결된 주변기기에서 인터럽트가 발생하는 것이고,
소프트웨어 인터럽트는 프로그램 처리 중 명령의 요청에 의해서 발생합니다.
</div>
</details>

<br>

<details>
<summary>Interrupt의 동작 순서</summary>

<br>

<div>
인터럽트 요청이 발생하면 현재 실행중인 프로그램을 중단합니다.
현재 실행중인 프로그램의 상태를 저장합니다.

<br>

인터럽트 요청이 발생한 장치를 식별한 후 인터럽트 서비스 루틴을 호출해 처리합니다.

인터럽트 처리가 끝나 상태복구 명령어가 실행되면, 저장된 Program Counter값을 통해 이전 실행 위치로 돌아가 수행중이던 프로그램을 재개합니다.

</div>
</details>

<br>

<details>
<summary>Interrupt와 Polling의 차이</summary>
<br>

<div>
Polling이란 CPU가 주변 기기들의 변화를 지속적으로 읽어 처리되어야할 작업을 찾는 과정입니다.

Polling은 CPU가 특정 이벤트를 처리하기위해 해당 이벤트가 발생할 때까지 주기적으로 확인해야합니다.
Interrupt는 다른 작업을 처리하다가 이벤트가 발생하면 인터럽트 핸들러를 호출해 작업을 처리합니다.
</div>

</details>

<br>

<details>
<summary>Interrupt Handler</summary>

<br>

<div>
인터럽트가 발생했을 때 인터럽트에 대응하여 이벤트를 처리하는 루틴입니다.
인터럽트 서비스 루틴이라고 부르기도 합니다. 인터럽트 핸들러의 예시로는 디바이스 드라이버가 있습니다.

CPU가 인터럽트 발생을 감지했을 때 CPU로부터 제어권을 넘겨받아 인터럽트를 처리합니다.
</div>
</details>

### Scheduler

<details>
<summary>Scheduler란?</summary>

<br>

<div>
스케줄러란 어떤 프로세스를 선택해서 CPU에서 실행시킬지 선택하는 모듈입니다.
스케줄러를 통해서 운영체제는 CPU를 사용하려는 프로세스 사이의 우선순위를 관리합니다.
이 과정을 스케줄링이라고 합니다.
</div>
</details>

<br>

<details>
<summary>스케줄러의 종류</summary>

<br>

<div>
단기 스케줄러, 중기 스케줄러, 장기 스케줄러가 있습니다.
단기 스케줄러는 CPU 스케줄러라고도 하며 ready 큐에 있는 프로세스들 중 선택하여 CPU를 할당합니다.
중기 스케줄러는 Swapper라고 하며 메모리에서 CPU를 점유하기 위해 경쟁하는 프로세스를 디스크로 보내는 스케줄러입니다.
장기 스케줄러는 Job 스케줄러라고도 하며 디스크 상의 프로세스를 선택해 ready 큐에 저장합니다.
</div>
</details>

<br>

<details>
<summary>Scheduling Queue</summary>

<br>

<div>
Ready Queue, Device Queue, Job Queue가 있습니다.
Ready Queue는 메모리에 로드되어 CPU를 점유해 실행되기를 기다리는 프로세스들의 집합입니다.
Device Queue는 I/O 작업을 대기하고 있는 프로세스의 집합입니다.
Job Queue는 디스크에 있는 프로그램이 실행 되기 위해 메모리의 할당 순서를 기다리는 프로세스들의 집합입니다.
</div>

</details>

<br>

<details>
<summary>CPU 스케줄링 결정 시점</summary>

<br>

<div>
CPU 스케줄링에서 스케줄링 결정 시점은 프로세스에 상태가 변화할 때 입니다.
스케줄링 적용 시점에 따라 선점형과 비선점형으로 구분됩니다.

1. Running 상태에서 Waiting 상태로 변할 때,
2. Running 상태에서 Ready 상태로 변할 때,
3. Waiting 상태에서 Ready 상태로 변할 때,
4. Running 상태에서 Exit 상태로 변할때 입니다.
</div>

#### 프로세스 상태
1. New 상태
   * 프로세스가 막 생성된 상태
2. Ready 상태
   * 프로세스가 CPU에 실행되기 위해 대기하는 상태
3. Running 상태
   * 프로세스에 포함된 명령어가 실행되고 있는 상태
4. Waiting 상태
   * 프로세스가 특정 자원이나 이벤트를 기다리는 상태
5. Terminated 상태
   * 프로세스가 실행을 완료한 상태

</details>

<br>

<details>
<summary>선점형 스케줄링</summary>

<br>

<div>

* 어떤 프로세스가 CPU를 할당받아 실행 중이어도 다른 프로세스가 실행중인 프로세스를 중지하고
CPU를 강제로 점유할 수 있습니다.
* 또한 모든 프로세스에게 CPU 사용시간을 동일하게 부여할 수 있습니다.
* 빠른 응답시간을 요궇는 시분할 시스템에 적합합니다.
* 운영체제가 프로세스 자원을 선점하고 있다가 프로세스의 요청이 있을 때 자원을 배분하는 방식입니다.
* 위 4가지 상황중 모든 상황에 수행됩니다.
* RR(Round Robin) 스케줄링, SRTF 스케줄링, 다단계 큐, 다단계 피드백 큐가 있습니다. 

</div>


#### Round Robin 스케줄링
* 시분할 시스템을 위해 설계된 선점형스케줄링의 하나로, 프로세스들 사이에 우선순위를 두지 않고
  순서대로 시간 단위로 CPU를 할당합니다.
* 시간 내 완료하지 못한 프로세스는 레디 큐의 맨 뒤에 배치하는 방식입니다.

#### SRTF 스케줄링 (Shortest Remaining Time)
* SJF 스케줄링을 비선점에서 선점 형태로 수정한 알고리즘입니다.
* 프로세스를 실행중 더 적은 CPU 작업 시간을 요구하는 프로세스가
  실행중인 프로세스를 중단하고 해당 프로세스를 실행합니다.
* SRT 스케줄링이라고도 합니다.
* 긴 CPU 작업시간을 요구하는 프로세스에게서 기아 문제가 발생할 수 있습니다.

#### 다단계 큐 스케줄링
* 서로 다른 우선순위의 프로세스들을 구별하고 관리하기 위해 우선순위 갯수만큼 큐가 필요합니다.
* 각 프로세스들은 자신의 우선순위에 맞게 큐에 들어가며, 우선순위가 낮은 프로세스는 작업을 실행중이더라도
상위 큐에 프로세스가 도착하면 CPU를 뺏기는 방식입니다.

#### 다단계 피드백 큐 스케줄링
* 각 단계마다 하나의 큐를 두고 큐 시간 할당량 내에 처리하지 못하면 다음 큐로 보내는 방식입니다.
* 단계가 커질수록 시간 할당량이 증가합니다.

</details>

<br>

<details>
<summary>비선점형 스케줄링</summary>

<br>

<div>

* 프로세스가 CPU를 할당 받으면 그 프로세스가 종료 되거나 I/O 처리를 위해 자발적으로 중지될 때까지
실행을 보장합니다.
* 순서대로 처리되며 프로세스와 관계없이 응답 시간을 예상할 수 있습니다.
* 일괄 처리 시스템에 적합합니다.
* CPU 사용 시간이 긴 프로세스가 다른 여러 프로세스를 오래 대기 시킬 수 있어 처리율이 떨어질 수 있습니다.
* 위 4가지 상황중 1, 4번 상황에 수행됩니다.
* FCFS 스케줄링, SJF 스케줄링, HRRN 스케줄링이 있습니다.
</div>

#### FCFS 스케줄링 (First Come First Served)
* 큐에 도착한 순서대로 실행합니다.
* 최악의 경우 CPU 점유시간이 긴 프로세스가 가장 먼저 도착해
  짧은 점유시간을 요구하는 프로세스들도 오랜시간 완료되지 못할 수 있습니다.

#### SJF 스케줄링 (Shortest Job First)
* CPU 점유 시간이 가장 짧은 프로세스에게 CPU를 먼저 할당하는 방식입니다.
* 기아 문제가 발생할 수 있습니다.

#### HRRN 스케줄링 (Highest Response Ratio Next)
* 레디 큐에서 기다리는 프로세스 중 응답비율이 가장 큰 것을 먼저 처리하는 방식입니다.
* 수행시간이 긴 프로세스의 기아 현상을 방지하기 위한 알고리즘입니다.
* 응답률 = (대기시간 + CPU 요구량) / CPU 요구량

</details>

### Kernel

<details>
<summary>커널이란?</summary>

<br>

<div>
운영체제의 핵심이 되는 컴퓨터 프로그램으로 시스템의 모든것을 완전히 제어합니다.
사용자와 직접 상호작용을 진행하지 않으며 Shell 프로그램이라는 시스템 프로그램을 통해 커넣에 명령을 할 수 있습니다.
</div>

* 커널
  * 기본적으로 소프트웨어가 시스템에서 수행되기 위해선 메모리에 프로그램이 올라가 있어야 합니다.
  * 운영체제 전체가 메모리에 올라가 있으면 메모리 공간에 낭비가 심하므로
    * 항상 필요한 부분만 메모리에 올리게 되는데 이 부분이 커널입니다.
</details>

<details>
<summary>시스템 호출</summary>

<br>

<div>
시스템 호출이란 커널을 보호하기 위해 만든 인터페이스로
사용자나 응용 프로그램에서 컴퓨터 자원을 보호하기 위해
직접 접근하는 것을 차단합니다.

<br>

컴퓨터 자원을 사용하기 위해서는 System Call이라는 인터페이스를 이용해 접근해야 합니다.
</div>

#### 모드
* 유저모드
  * 사용자가 접근할 수 있는 영역을 제한하고 프로그램의 자원에 함부로 접근하지 못하는 모드입니다.
  * 프로세스를 실행하고 코드를 작성하는 행동들이 여기에 해당합니다.
* 커널모드
  * 모든 자원에 접근하거나 명령할 수 있습니다.

* System Call을 이용해 유저모드에서 커널모드로 요청을 보낼 수 있고,
커널모드에서 유저모드로 응답을 반환할 수 있습니다.
</details>