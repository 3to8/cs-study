### 영속성 컨텍스트

<details>
<summary>영속성 컨텍스트란?</summary>

<br>

<div>
엔티티를 영구 저장하는 환경을 말합니다.
애플리케이션과 데이터베이스 사이에서 영구적으로 저장될 엔티티 객체를 보관합니다.
</div>
</details>

<br>

<details>
<summary>엔티티 매니저</summary>

<br>

<div>
영속성 컨텍스트에서 엔티티를 관리하며 엔티티를 저장, 삭제, 수정, 조회하는 동작을 처리합니다.
</div>

* 엔티티 매니저 팩토리에서 엔티티 매니저를 생성합니다.
  * 엔티티 매니저 팩토리를 생성하는 비용은 매우 크기 때문에 일반적으로 애플리케이션에서 하나만 만들어서 사용합니다.
  * 그에 비해 엔티티 매니저는 생성 비용이 크지 않기 때문에 각 요청마다 별도의 엔티티 매니저를 생성해 사용합니다.
* 엔티티 매니저는 thread safe 하지 않기 때문에 여러 thread 간 공유 해서는 안됩니다.
</details>

<br>

<details>
<summary>엔티티 생명주기</summary>

<br>

<div>
비영속, 영속, 준영속, 삭제가 있습니다.
</div>

#### 비영속 (new / transient)
* 영속성 컨텍스트와 관계가 없는 상태입니다.

#### 영속 (managed)
* 영속성 컨텍스트에 저장된 상태입니다.
* 트랜잭션의 작업이 완료된 시점에 DB에 쿼리로 전달됩니다.

#### 준영속 (detached)
* 영속성 컨텍스트에서 저장되었다가 분리된 상태입니다.
* 영속성 컨텍스트가 제공하는 기능을 사용하지 못합니다.

* detach, clear, close 메소드를 통해서 준영속 상태로 만들 수 있습니다.
  * detach : 특정 엔티티만 준영속 상태로 전환
  * clear : 영속성 컨텍스트 초기화
  * close : 영속성 컨텍스트 종료

#### 삭제 (removed)
* 영속성 컨텍스트와 데이터베이스에서 삭제된 상태입니다.

</details>

<details>
<summary>영속성 컨텍스트 장점</summary>

<br>

<div>
1차 캐시, 동일성 보장, 쓰기 지연, 변경 감지, 지연 로딩이 있습니다.
</div>

#### 1차 캐시
* 한 트랜잭션에서 동일한 데이터를 여러번 조회시 실제 조회는 1번만 이루어 지고 나머지 조회는 캐시에서 응답합니다.

#### 동일성 보장
* 한 트랜잭션에서 동일한 객체를 조회하면 같은 객체로 반환합니다.

#### 쓰기 지연
* 한 트랜잭션에서 여러 쿼리가 발생하면 영속성 컨텍스트에 쿼리를 저장해 두었다가 Commit 될 때 쿼리들이 실행됩니다.
* JPQL으로 조회 시 Flush가 실행 되 쿼리 결과가 반영되어 쓰기 지연이 적용 되지 않습니다.
* 기본키 전략을 IDENTITY로 설정한 경우에도 마찬가지로 쓰기 지연이 적용되지 않습니다.

#### 변경 감지
* 영속성 컨텍스트 내부에 데이터가 조회될 때 데이터의 정보를 기록해둬 데이터에 변경이 일어나면 Update 쿼리를 생성해 Commit 될 때 쿼리를 실행합니다.

#### 지연 로딩
* 엔티티가 실제로 사용되기 전까지 데이터베이스의 조회를 지연시키는 특징입니다.
</details>
